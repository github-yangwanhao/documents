# 数据库索引失效的场景

- 模糊查询%在左边
- 联合索引不满足最左前缀原则
- SQL条件使用了计算或者函数操作
- 查询条件发生了隐式的类型转换，比如作为条件的字符串没有加单引号
- 使用OR关键字查询，如果所有OR的字段没有全部加上索引就会导致索引失效
- 使用 != 或者 <> 操作符会导致索引失效
- 索引行占比过少，或者表数据太少，导致SQL优化器认为无需使用索引
- 两列对比，如select * from user where user_id = out_user_id
- order by条件没有索引
- in的数量太多可能导致索引失效
- not in会导致索引失效
- is null 或者 is not null会导致索引失效
- 两表关联的时候关联字段的类型、长度不一致会导致索引失效

# SQL优化常用手段

- 增加合适的查询索引，并且在查询SQL中避免索引失效的问题。
- 避免使用select *，避免返回不需要的数据列，尽量使用覆盖索引。
- 尽量使用join连接查询来代替子查询。
- 分库分表分区，读写分离。
- 设计阶段适当的冗余一些字段，避免连表查询。
- 使用explain分析SQL。
- 小表驱动大表。
- or的查询尽量使用union或者union all代替

# 常用索引类型

- 主键索引
- 唯一索引
- 普通索引
- 聚合索引

# Explain关键字的字段含义

id: 查询中每个select子句的标识符。

select_type: 查询类型（如SIMPLE, PRIMARY, UNION, DEPENDENT UNION等）。

table: 查询的表名。

partitions: 查询的分区信息。

type: 联接类型。比如const、ref、range、index、all。

possible_keys: 可能用到的索引。

key: 实际使用的索引。

key_len: 索引的长度。

ref: 列与索引的比较。

rows: 估计需要检查的行数。

filtered: 表示此查询条件过滤后，剩余的行数百分比。

Extra: 额外的信息。

# 查询需要事务吗

1、如果只是单个的查询，不需要事务。

2、对于多条查询SQL。如果当时数据库的隔离级别是RC(读已提交)，那么不需要加事务，因为查到的永远都是最新提交的数据；如果数据库的隔离级别是RR(可重复读)，且业务逻辑需要保证查询到的多条SQL的结果保持在同一时间，那就需要加事务。因为可重复读读取到的永远是本事务内第一次查询产生的数据快照。

# MySQL的锁概念

MySQL的锁可以从以下五个方面划分：

- 粒度分类：全局锁、表锁、行锁
- 模式分类：悲观锁、乐观锁
- 属性分类：共享锁、排它锁
- 状态分类：意向共享锁、意向排它锁
- 算法分类：间隙锁、记录所、邻键锁

分别从每个方面解释每个锁的意思

- 粒度分类

  - 全局锁：针对整个数据库加锁。可读不可写。使用FLUSH TABLES WITH READ LOCK加锁；使用UNLOCK TABLES解锁。

  - 表锁：针对某张表整体加锁。

    - 表共享读锁：可读不可写。使用LOCK TABLES XXX READ加锁;使用UNLOCK TABLES解锁。
    - 表共享写锁：不可读也不可写。使用LOCK TABLES XXX WRITE加锁;使用UNLOCK TABLES解锁。
    - 其他会锁表的场景：ALTER TABLE；DROP TABLE；TRUNCATE TABLE；

  - 行锁：粒度最小的锁。

    - 共享锁：可以理解为读锁。在一个事务里使用SELECT....... LOCK IN SHARE MODE加锁，事务提交后自动释放锁。共享锁的特点是多个事务可以同时对一条数据加锁，如下SQL在多个connection中均可同时执行。

      ```mysql
      -- 开启一个事务
      start transaction;
      -- 加上共享锁
      select * from partition_test where id = 'XXX' lock in share mode ;
      -- 先不执行提交，同时在其他connection中执行上面两句SQL，发现可以执行成功，最后提交
      commit;
      ```

    - 排它锁：可以理解为写锁。在一个事务里使用SELECT.......FOR UPDATE加锁，事务提交后自动释放锁。排他锁的特点是只有一个事务可以对这条数据加锁。

      ```mysql
      -- 开启一个事务
      start transaction;
      -- 加上排它锁
      select * from partition_test where id = 'XXX' for update;
      -- 先不执行提交，同时在其他connection中执行上面两句SQL，发现一直在等待锁的释放，然后回到这里执行提交后可以发现另一个connection才可以加锁成功
      commit;
      ```

- 模式分类

  - 悲观锁：上面提到的全局锁、表锁、行锁都是悲观锁。
  - 乐观锁：mysql本身没有实现乐观锁，通常由业务代码实现。如在数据行中通过版本号字段或者最后更新时间字段来判断数据有没有被修改过。

- 属性分类：共享锁、排它锁，可以参考行锁中的共享锁和排它锁特点。

- 状态分类：意向共享锁、意向排它锁。首先意向锁都是表锁，是为了协调行锁和表锁而存在的。事务A添加的行锁会同时添加意向锁，事务B申请表锁时不需要判断是否存在行锁，只需要判断是否存在意向锁即可。

- 算法分类

  - 间隙锁：锁定的是两个索引之间的区间。SELECT * FROM XXX WHERE id > 1 AND id < 4 FOR UPDATE;

  - 记录所：其实就可以理解为行锁。

  - 邻键锁：每个数据行的非唯一索引列都会存在一个左开右闭的区间，就是邻键锁。

    | id(主键唯一索引) | age(非唯一索引) | name |
    | :--------------: | :-------------: | :--: |
    |        1         |       18        | 张三 |
    |        2         |       23        | 李四 |
    |        3         |       30        | 王五 |
    |        4         |       45        | 马六 |

    如上面的数据库表，潜在的邻键锁就会有(-∞,18]，(18,23]，(23,30]，(30,45]，(45,+∞]五个邻键锁。当我们使用SELECT * FROM USER WHERE age=23 FOR UPDATE锁住23时，其实锁住的是(23,30]这个区间。



# 脏读、幻读、不可重复读

脏读：事务A更新了数据，但没有提交；事务B读取了事务A更新后的数据。然后事务A回滚了，事务B读取到的数据是无效的。

幻读：事务A读取某一范围内的数据后，数据B在该范围内又新增了一条数据并提交，事务A再次读取该范围数据后发现有新的数据行。举例：事务A第一次查询id>1 AND id <5的数据范围，查询到的结果只有id=2和id=3的数据，这时事务B新增了一条id=4的数据，那么事务A再用相同的SQL执行查询时，会得到3条数据。

不可重复读：事务A读取记录后(age=18)，事务B更新了记录(age=20)并提交，事务A再次读取时可以看到事务B修改后的记录(age=20)。通俗点说：事务A第一次读到的数据(age=18)和第二次读到的(age=20)不一致。

幻读和不可重复读的区别：幻读更倾向于insert操作，不可重复读更倾向于update操作。

# 数据库四大隔离级别

1. 读未提交(Read Uncommitted)：事务A修改的数据，即便A还没有提交，也可以被事务B读取到。可能会因此出现脏读、幻读和不可重复读。
2. 读已提交(Read Committed)：事务中修改的数据，只能等事务提交后才能够被读取到。可能会因此产生不可重复读和幻读。
3. 可重复读(Repeatable Read)：`是Innodb引擎默认的隔离级别`，事务开始读数据的时候，就会生成一个数据快照，同一事物中后边读取到的数据都是从数据快照中读取的。但是，它不会锁住insert的数据，因此依然会存在幻读的情况。
4. 串行化(Serializable)：串行化是最高的隔离级别。它通过强制事务串行执行，避免了前面的幻读情况。由于它大量加上锁，导致大量的请求超时，因此性能会比较低下。在特别需要数据一致性且并发量不大的时候才可能会考虑使用这个隔离级别。

# 事务的四个ACID特性

- 原子性：Atomicity，即组成事务的多个数据库操作是不可分割的原子单元。所以一个事务中的所有操作要么全部成功进而提交，要么有任意一个或多个失败，那么即便是其他已成功的操作也要回滚让数据库恢复到事务开始之前的状态。
- 一致性：Consistency，事务操作提交成功后，数据库所处的状态和他的业务规则是一致的，即数据不会被破坏。
- 隔离性：Isolation，在并发进行数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对其他事物产生干扰。**准确地说，并非是完全无干扰。数据库规定了多种事务隔离级别，不同的隔离级别对应不同的干扰程度。隔离级别越高，数据一致性越好，但并发性越弱**。
- 持久性：Durability，一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中。即使在事务提交后，数据库马上崩溃，在数据库重启时，也必须保证能够通过某种机制恢复数据。



# MVCC是什么

多版本并发控制（MVCC=Multi-Version Concurrency Control）。是指在数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务可见性保证事务能看到自己应该看到的数据。

MVCC最大的好处是读不加锁，读写不冲突。目前的MVCC只在Read Committed和Repeatable Read两种隔离级别下工作。

1、数据库的三个隐藏字段。

- DB_ROW_ID：如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么innoDB会自动为表添加一个主键列。
- DB_TRX_ID：事务中对某条记录做增删改时，会将该事务的ID写入该字段。
- DB_ROLL_PTR：回滚指针，指向undo log的指针。

2、Read View是innodb在实现MVCC时用到的一次性视图，用于支持RC和RR隔离级别的实现。Read View简单来说就是将数据在每个时刻的状态记录下来成为快照，那么之后获取某时刻的数据时就还是原来快照上的数据。

Read View中有四个比较重要的字段：

- m_ids：用来表示MySQL中哪些事务正在执行，没有提交
- min_trx_id：就是m_ids中最小的值
- max_trx_id：下一个要生成的事务id，也就是最大的事务id
- creator_trx_id：当前事务的id

通过Read View判断记录的某个版本是否可见的方式总结：

- trx_id = creator_trx_id

  如果被访问的版本的trx_id和当前事务的trx_id一致，那么说明就是当前事务在访问自己修改过的记录，该版本可以被当前事务访问。

- trx_id < min_trx_id

  如果被访问版本的trx_id小于Read View中最小的事务id，表明该版本事务在当前事务生成Read View前就已经提交了，该版本可以被当前事务访问。

- trx_id >= max_trx_id

  如果被访问版本的trx_id大于或者等于Read View中最大的事务id，表明该版本事务在当前事务生成Read View之后才被开启，那么该版本不可以被当前事务访问。

- trx_id > min_trx_id && trx_id < max_trx_id

  如果被访问版本的trx_id的值在min_trx_id和max_trx_id之间，就需要判断trx_id是否在m_ids列表中？

  - 在：说明创建Read View时该版本事务还是活跃的，该版本不可以被访问。
  - 不在：说明创建Read View时该版本事务已经被提交，该版本可以被访问。

何时生成Read View数据快照？

- 在读已提交Read Committed隔离级别中，每一次读取数据前都生成一个Read View。
- 在可重复读Repeatable Read隔离级别中，一个事务中，只在第一次读取数据前生成一个Read View。

# MySQL中InnoDB引擎和MyISAM引擎的区别

- 数据存储方式不同：MyISAM引擎的数据和索引是分开存储的；InnoDB则是数据和索引存在一个文件里。
- 对于事务支持不同：MyISAM不支持事务；InnoDB支持ACID特性的事务处理。
- 锁的支持不同：MyISAM只支持表锁；InnoDB支持表锁、行锁、间隙锁、邻键锁。
- 对于外键的支持：MyISAM不支持外键；InnoDB支持外键。
- SELECT COUNT(*) FROM TABLE的处理机制：MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；InnoDB不保存表的行数，使用SELECT COUNT(\*) FROM TABLE时需要扫描全表。
- 对于全文索引的支持：MyISAM支持全文索引；InnoDB不支持全文索引。
- 对于自增主键的处理不同：如果使用自增ID插入后又删除了这条数据，那么关于下一条数据的自增ID处理是不一样的。MyISAM表会把自增主键的最大ID记录到表数据文件里，重启MySQL自增主键的最大ID也不会丢失；InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库会导致最大ID丢失,会以表中实际存在的最大主键为准。

# MySQL默认的数据引擎是哪个？

在MySQL5.5版本之前，默认的数据引擎是MyISAM；在MySQL5.5版本及之后，默认数据引擎是InnoDB。

# SQL中七种join

![img](images/6f9c02a8fac74be74e0e817b5ceceb64.png)

# 数据库索引的优缺点

优点：

- 减少数据检索时的磁盘IO次数，从而提升数据查询效率。
- 分组和排序子句检索的时候，也可以提升效率。
- 通过主键索引或者唯一索引可以对数据的唯一性做约束。

缺点：

- 数据的增删改操作都需要对索引做维护，数据量比较大的时候索引操作也会增加消耗。
- 如果字段离散性太差，且数据量很大的时候，创建错误的索引不仅不会提高查询效率反而还会带来额外的消耗。

# SQL语句关键字的执行顺序

如下SQL所示：SELECT * FROM table WHERE id < 10 GROUP BY id HAVING COUNT(*) > 1 ORDER BY id;

1. FROM 子句, 组装来自不同数据源的数据
2. WHERE 子句, 基于指定的条件对记录进行筛选
3. GROUP BY 子句, 将数据划分为多个分组
4. 使用COUNT(*)聚合函数进行计算
5. 使用 HAVING 子句筛选分组
6. 计算所有的表达式
7. 使用 ORDER BY 对结果集进行排序
8. 输出SELECT

即：from—>where—>group by—>having—>计算所有的表达式—>order by—>select 输出

# 数据库表设计的注意事项有哪些

- 字段的原子性：保证每列的原子性不可分解，能用一个字段表达清楚的绝不分解成两个字段。
- 主键设计：主键不要和业务逻辑关联，最好是一串无意义的数字。
- 外键：尽量不要使用外键，保证表的独立性，方便表结构变更或者数据迁移。
- 字段长度：如果不是非常确定长度的值，尽量定义长度比实际最大长度多出3-5位；最好是2的n次方幂值。
- 对于固定的值使用code(字母或者数字)代替其真实含义，真实含义可以在建表语句的字段说明提现。
- 如果一定要使用大字段(blob类型或者text类型)，最好独立出一张表来。
- 业务逻辑中尽量不要使用物理删除(delete)，使用状态控制逻辑删除。

# 数据库三范式

1. 第一范式（1NF）：确保数据库中的每个列都是原子性的，即不可再分的最小数据单位。这意味着每一列都应包含一个独立的数据项，如一个学生的姓名和年龄，应分为两个不同的列。
2. 第二范式（2NF）：在满足第一范式的基础上，要求非主键列完全依赖于主键，而不是主键的一部分。这有助于消除数据冗余，并确保数据的唯一性。
3. 第三范式（3NF）：在满足第二范式的基础上，要求非主键列不依赖于其他非主键列，即任何非主属性不依赖于其他非主属性。这有助于避免数据冗余和确保数据的独立性。

# 查看执行计划的方法

- MySQL：EXPLAIN关键字
- Oracle：
  - EXPLAIN PLAN FOR + SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

# 数据库常用函数

1. 聚合函数：
   - AVG()：返回某字段的平均值
   - COUNT()：返回某字段的总行数
   - MAX()：返回某字段的最大值
   - MIN()：返回某字段的最小值
   - SUM()：返回某字段的和
2. 数学函数：
   - CEIL(X)：返回大于或者等于数值X的最小整数
   - FLOOR(X)：返回小于或者等于数值X的最大整数
   - ROUND(X)：返回数值X的四舍五入结果
   - RAND()：返回0-1之间的随机小数值(可能会有很多位小数)
   - TRUNCATE(X,D)：返回数值X保留小数点后D位的值，直接截取
   - ROUND(X,D)：返回数值X保留小数点后D位的值，四舍五入
   - SIGN(X)：如果X大于0，返回1；如果X等于0，返回0，如果X小于0，返回-1
3. 字符串函数：
   - CONCAT(str1,str2...)：按顺序拼接字符串，返回拼接后的值
   - INSERT(oldStr,start,length,newStr)：字符串替换，从start下标的位置开始总共length个字符替换为新的字符串。例：`select insert('123456789', 3, 2, '三四');`输出结果为`12三四56789`
   - LOWER(str)：将字符串转换为小写
   - UPPER(str)：将字符串转换为大写
   - SUBSTRING(str,start,length)：字符串截取，返回从start开始的共计length个字符的字符串。例：`select substring('123456789', 3, 2);`输出结果为`34`
   - SUBSTR(str FROM start FOR length)：效果等同于`SUBSTRING(str,start,length)`

# Oracle的常用函数

1、NVL(表达式1, 表达式2)：如果表达式1为空值，NVL返回值为表达式2的值，否则返回表达式1的值。

# HAVING和WHERE的区别

- 作用对象不同：WHERE子句用于筛选记录，即在分组之前对数据行进行过滤；而HAVING子句用于筛选组，即在分组之后对数据行进行过滤。
- 使用聚合函数的情况不同：WHERE子句中不能使用聚合函数，如SUM()、AVG()等；而HAVING子句中可以使用聚合函数。
- 配合使用的子句不同：WHERE子句可以不用任何子句的配合；而HAVING子句通常与GROUP BY子句一起使用，因为having的作用是对使用group by进行分组统计后的结果进行进一步的筛选。
- 执行顺序不同：先执行WHERE子句，再执行HAVING子句。
- 出现的字段不同：HAVING子句中不能出现既不被GROUP BY子句包含，又不被聚合函数包含的字段；而WHERE子句中可以出现任意的字段。
- 筛选的结果相同：在使用WHERE子句或HAVING子句都能查询出相同的结果时，WHERE子句放在GROUP BY子句之前，而HAVING子句放在GROUP BY子句之后。

# MySQL的四种索引

- 主键索引(PRIMARY)：数据列不允许重复，不允许为NULL，一个表只能有一个主键。
- 唯一索引(UNIQUE)：数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。
  - 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引
  - 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引
- 普通索引(INDEX)：
  - 可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引
  - 可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2,column3); 创建组合索引
- 全文索引(FULLTEXT)：可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引

# DROP、DELETE和TRUNCATE的区别

DELETE和TRUNCATE只删除数据不会删除表结构，而DROP用于将表结构和数据一起删除。

TRUNCATE只能整表删除，DELETE可以条件删除，如果确实要整表删除，建议使用TRUNCATE。

DELETE语句是DML，这个操作会被放到rollback segment中，事务提交之后才生效；如果有相应的trigger，执行的时候将被触发。

TRUNCATE、DROP是DDL， 操作立即生效，原数据不放到rollback segment中,不能回滚. 操作不触发trigger。

删除速度上来说，DROP>TRUNCATE>DELETE。

DROP和TRUNCATE会锁全表，DELETE通常会是行锁，只有在索引失效的情况下才会升级到表锁。

# 若一张表中只有一个字段VARCHAR(N)类型，编码类型为utf8，则MySQL中N最大值为多少?

由于utf8的每个字符最多占用3个字节。而MySQL定义行的长度不能超过 65535，因此N的最大值计算方法为：(65535-1-2)/3。减去1的原因是实 际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符 长度，除以3是因为utf8限制：每个字符最多占用3个字节。

# [SELECT *]和[SELECT 全部字段]各有什么优缺点

1. 前者要解析数据字典，后者不需要
2. 结果输出顺序：前者与建表列顺序相同，后者按指定字段顺序
3. 表字段改名，前者不需要修改，后者需要改
4. 后者可以建立索引进行优化，前者无法优化
5. 后者的可读性比前者要高 

# MySQL当记录不存在时insert,当记录存在时update，语句怎么写

INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY  UPDATE c=c+1; 