# Spring的事务传播机制

| 事务传播机制  |                             解释                             |   外部不存在事务   |                         外部存在事务                         |
| :-----------: | :----------------------------------------------------------: | :----------------: | :----------------------------------------------------------: |
|   REQUIRED    | 默认的Spring事物传播级别，若当前存在事务，则加入该事务，若 不存在事务，则新建一个事务 |     开启新事务     |                      融入并使用外部事物                      |
| REQUIRED_NEW  |  不管外部有没有事务都创建一个新的事务，适合于流水登记等场景  |     开启新事务     |                       开启一个新的事务                       |
|    NESTED     | 没有事务， 新建一个事务；存在事务，则新建一个事物**嵌套**在外部事务中。外部事物回滚新事物一定回滚，新事物回滚不一定回滚外部事物。 |     开启新事务     | 创建一个新的事务**嵌套**在外部事物中执行，结合数据库的savePoint功能使用。 |
|   SUPPORTS    |                 支持事务，但是不主动开启事务                 | 以非事务的方式执行 |                         融入外部事物                         |
|   MANDATORY   |              强制使用事务，不存在事务则抛出异常              |     抛出异常×      |                         融入外部事物                         |
| NOT_SUPPORTED |                不支持事务，以非事务的方式运行                | 以非事务的方式执行 |               挂起外部事物，以非事务的方式执行               |
|     NEVER     |                不支持事务，存在事务则抛出异常                | 以非事务的方式执行 |                          抛出异常×                           |

# Spring事务失效的场景

1. bean未被Spring管理。
2. 类内调用，没有经过代理增强。
3. 方法的访问权限不为public，或者方法被static、final关键字修饰导致不可重写。
4. 方法的异常被内部捕捉没有抛出，spring感知不到。
5. @Transactional注解的rollbackFor属性没有赋值，默认为RuntimeException和Error，那么一些CheckException就不会被spring感知并回滚事务。
6. 多线程调用。spring事务是通过代理和数据库连接实现的，数据库连接对象被存放在ThreadLocal中，多线程会导致使用不一样的数据库连接。
7. 使用了错误的传播机制。
8. 数据库本身不支持事务。

# Spring如何解决循环依赖

Spring通过三级缓存来解决循环依赖的问题，也就是三个Map。

一级缓存：存储完整的bean

二级缓存：避免多重循环依赖重复创建动态代理

三级缓存：存储的是lambda函数接口，把bean的实例和名字作为方法参数传进去，进行aop动态代理的创建。会在第二次调用的时候才会调用三级缓存，然后放入二级缓存。

整个流程大致如下：

1. 首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在 初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建 出来；
2. 然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来； 
3.  这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)。这 个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories），通过 ObjectFactory 提前曝光，所以可以通过 ObjectFactory#getObject() 方法来拿到 A 对象。C 拿 到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中；
4.  回到 B，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路 就已经完成了初始化过程了。



多例bean不能解决循环依赖，因为多例bean不使用缓存，而解决循环依赖一定要依赖于缓存。

# Spring用到了哪些设计模式

- 简单工厂模式：beanFactory
- 单例模式：默认产生的Spring bean都是单例的
- 代理模式：AOP
- 观察者模式：Spring事件发布和监听
- 责任链模式：AOP的方法调用
- 模板方法模式：对外预留测自定义扩展接口



# 