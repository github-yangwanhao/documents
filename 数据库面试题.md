# 数据库索引失效的场景

- 模糊查询%在左边
- 联合索引不满足最左前缀原则
- SQL查询条件使用了计算或者函数操作
- 查询条件发生了隐式的类型转换，比如作为条件的字符串没有加单引号
- 使用OR关键字查询，如果所有OR的字段没有全部加上索引就会导致索引失效
- 索引行占比过少，或者表数据太少，导致SQL优化器认为无需使用索引
- 两列对比，如select * from user where user_id = out_user_id
- order by 条件没有索引
- in的数量太多可能导致索引失效

# SQL优化常用手段

- 增加合适的查询索引，并且在查询SQL中避免索引失效的问题。
- 避免使用select *，避免返回不需要的数据列，尽量使用覆盖索引。
- 尽量使用join连接查询来代替子查询。
- 分库分表分区，读写分离。
- 设计阶段适当的冗余一些字段，避免连表查询。
- 使用explain分析SQL。
- 小表驱动大表。

# 查询需要事务吗

1、如果只是单个的查询，不需要事务。

2、对于多条查询SQL。如果当时数据库的隔离级别是RC(读已提交)，那么不需要加事务，因为查到的永远都是最新提交的数据；如果数据库的隔离级别是RR(可重复读)，且业务逻辑需要保证查询到的多条SQL的结果保持在同一时间，那就需要加事务。因为可重复读读取到的永远是本事务内第一次查询产生的数据快照。

# mysql的锁概念

mysql的锁可以从以下五个方面划分：

- 粒度分类：全局锁、表锁、行锁
- 模式分类：悲观锁、乐观锁
- 属性分类：共享锁、排它锁
- 状态分类：意向共享锁、意向排它锁
- 算法分类：间隙锁、记录所、邻键锁

分别从每个方面解释每个锁的意思

- 粒度分类

  - 全局锁：针对整个数据库加锁。可读不可写。使用FLUSH TABLES WITH READ LOCK加锁；使用UNLOCK TABLES解锁

  - 表锁：针对某张表整体加锁。

    - 表共享读锁：可读不可写。使用LOCK TABLES XXX READ加锁;使用UNLOCK TABLES解锁。
    - 表共享写锁：不可读也不可写。使用LOCK TABLES XXX WRITE加锁;使用UNLOCK TABLES解锁。
    - 其他会锁表的场景：ALTER TABLE；DROP TABLE；TRUNCATE TABLE；

  - 行锁：粒度最小的锁。

    - 共享锁：可以理解为读锁。在一个事务里使用SELECT....... LOCK IN SHARE MODE加锁，事务提交后自动释放锁。共享锁的特点是多个事务可以同时对一条数据加锁，如下SQL在多个connection中均可同时执行。

      ```mysql
      -- 开启一个事务
      start transaction;
      -- 加上共享锁
      select * from partition_test where id = 'XXX' lock in share mode ;
      -- 先不执行提交，同时在其他connection中执行上面两句SQL，发现可以执行成功，最后提交
      commit;
      ```

    - 排它锁：可以理解为写锁。在一个事务里使用SELECT....... FOR UPDATE加锁，事务提交后自动释放锁。排他锁的特点是只有一个事务可以对这条数据加锁。

      ```mysql
      -- 开启一个事务
      start transaction;
      -- 加上排它锁
      select * from partition_test where id = 'XXX' for update;
      -- 先不执行提交，同时在其他connection中执行上面两句SQL，发现一直在等待锁的释放，然后回到这里执行提交后可以发现另一个connection才可以加锁成功
      commit;
      ```

- 模式分类

  - 悲观锁：上面提到的全局锁、表锁、行锁都是悲观锁。
  - 乐观锁：mysql本身没有实现乐观锁，通常由业务代码实现。如在数据行中通过版本号字段或者最后更新时间字段来判断数据有没有被修改过。

- 属性分类：共享锁、排它锁，可以参考行锁中的共享锁和排它锁特点。

- 状态分类：意向共享锁、意向排它锁。首先意向锁都是表锁，是为了协调行锁和表锁而存在的。事务A添加的行锁会同时添加意向锁，事务B申请表锁时不需要判断是否存在行锁，只需要判断是否存在意向锁即可。

- 算法分类

  - 间隙锁：锁定的是两个索引之间的区间。SELECT * FROM XXX WHERE id > 1 AND id < 4 FOR UPDATE;

  - 记录所：其实就可以理解为行锁。

  - 邻键锁：每个数据行的非唯一索引列都会存在一个左开右闭的区间，就是邻键锁。

    | id(主键唯一索引) | age(非唯一索引) | name |
    | :--------------: | :-------------: | :--: |
    |        1         |       18        | 张三 |
    |        2         |       23        | 李四 |
    |        3         |       30        | 王五 |
    |        4         |       45        | 马六 |

    如上面的数据库表，潜在的邻键锁就会有(-∞,18]，(18,23]，(23,30]，(30,45]，(45,+∞]五个邻键锁。当我们使用SELECT * FROM USER WHERE age=23 FOR UPDATE锁住23时，其实锁住的是(23,30]这个区间。



# 脏读、幻读、不可重复读

脏读：事务A更新了数据，但没有提交；事务B读取了事务A更新后的数据。然后事务A回滚了，事务B读取到的数据是无效的。

幻读：事务A读取某一范围内的数据后，数据B在该范围内又新增了一条数据并提交，事务A再次读取该范围数据后发现有新的数据行。举例：事务A第一次查询id>1 AND id <5的数据范围，查询到的结果只有id=2和id=3的数据，这时事务B新增了一条id=4的数据，那么事务A再用相同的SQL执行查询时，会得到3条数据。

不可重复读：事务A读取记录后(age=18)，事务B更新了记录(age=20)并提交，事务A再次读取时可以看到事务B修改后的记录(age=20)。通俗点说：事务A第一次读到的数据(age=18)和第二次读到的(age=20)不一致。



# 数据库四大隔离级别

1. 读未提交(Read Uncommitted)：事务A修改的数据，即便A还没有提交，也可以被事务B读取到。可能会因此出现脏读、幻读和不可重复读。
2. 读已提交(Read Committed)：事务中修改的数据，只能等事务提交后才能够被读取到。可能会因此产生不可重复读和幻读。
3. 可重复读(Repeatable Read)：事务开始读数据的时候，就会生成一个数据快照，同一事物中后边读取到的数据都是从数据快照中读取的。但是，它不会锁住insert的数据，因此依然会存在幻读的情况。
4. 串行化(Serializable)：串行化是最高的隔离级别。它通过强制事务串行执行，避免了前面的幻读情况。由于它大量加上锁，导致大量的请求超时，因此性能会比较低下。在特别需要数据一致性且并发量不大的时候才可能会考虑使用这个隔离级别。



# 事务的四个特性

- 原子性：即组成事务的多个数据库操作是不可分割的原子单元。所以一个事务中的所有操作要么全部成功进而提交，要么有任意一个或多个失败，那么即便是其他已成功的操作也要回滚让数据库恢复到事务开始之前的状态。
- 一致性：事务操作提交成功后，数据库所处的状态和他的业务规则是一致的，即数据不会被破坏。
- 隔离性：在并发进行数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对其他事物产生干扰。准确地说，并非是完全无干扰。数据库规定了多种事务隔离级别，不同的隔离级别对应不同的干扰程度。隔离级别越高，数据一致性越好，但并发性越弱。
- 持久性：一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中。即使在事务提交后，数据库马上崩溃，在数据库重启时，也必须保证能够通过某种机制恢复数据。



# MVCC是什么

多版本并发控制（MVCC=Multi-Version Concurrency Control）。是指在数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务可见性保证事务能看到自己应该看到的数据。

MVCC最大的好处是读不加锁，读写不冲突。目前的MVCC只在Read Committed和Repeatable Read两种隔离级别下工作。

1、数据库的三个隐藏字段。

- DB_ROW_ID：如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么innoDB会自动为表添加一个主键列。
- DB_TRX_ID：事务中对某条记录做增删改时，会将该事务的ID写入该字段。
- DB_ROLL_PTR：回滚指针，指向undo log的指针。

2、Read View是innodb在实现MVCC时用到的一次性视图，用于支持RC和RR隔离级别的实现。Read View简单来说就是将数据在每个时刻的状态记录下来成为快照，那么之后获取某时刻的数据时就还是原来快照上的数据。

Read View中有四个比较重要的字段：

- m_ids：用来表示MySQL中哪些事务正在执行，没有提交
- min_trx_id：就是m_ids中最小的值
- max_trx_id：下一个要生成的事务id，也就是最大的事务id
- creator_trx_id：当前事务的id

通过Read View判断记录的某个版本是否可见的方式总结：

- trx_id = creator_trx_id

  如果被访问的版本的trx_id和当前事务的trx_id一致，那么说明就是当前事务在访问自己修改过的记录，该版本可以被当前事务访问。

- trx_id < min_trx_id

  如果被访问版本的trx_id小于Read View中最小的事务id，表明该版本事务在当前事务生成Read View前就已经提交了，该版本可以被当前事务访问。

- trx_id >= max_trx_id

  如果被访问版本的trx_id大于或者等于Read View中最大的事务id，表明该版本事务在当前事务生成Read View之后才被开启，那么该版本不可以被当前事务访问。

- trx_id > min_trx_id && trx_id < max_trx_id

  如果被访问版本的trx_id的值在min_trx_id和max_trx_id之间，就需要判断trx_id是否在m_ids列表中？

  - 在：说明创建Read View时该版本事务还是活跃的，该版本不可以被访问。
  - 不在：说明创建Read View时该版本事务已经被提交，该版本可以被访问。

何时生成Read View数据快照？

- 在读已提交Read Committed隔离级别中，每一次读取数据前都生成一个Read View。
- 在可重复读Repeatable Read隔离级别中，一个事务中，只在第一次读取数据前生成一个Read View。



# 